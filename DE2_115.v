
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE2_115(

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,
	output		     [6:0]		HEX6,
	output		     [6:0]		HEX7
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

    //clock key0 clock e ~key1 reset

    //Pc_counter
    wire [31:0] pcOut;
    wire [31:0] pcIn;

    //intruçoes memoria
    wire [31:0] instruction;

    //controlador
    wire ALUSrc;
    wire MemtoReg;
    wire RegWrite;
    wire MemRead;
    wire MemWrite;
    wire Branch;
    wire jump;
    wire [1:0] Aluop;

    //registradores
    wire [31:0] WriteData;
    wire [31:0] Wd1;
    wire [31:0] Rd1;
    wire [31:0] Rd2;

    //immGen
    wire [31:0] immediate;

    //ALUcontrole
    wire [3:0] controle_alu;

    //ALU
    wire  [31:0] resultado_alu;
    wire zero;

    //DataMemory
    wire [31:0] readData;

    //branch
    wire saida_branch;

    //mux
    wire [31:0] ent0;
    wire [31:0] ent1;
    wire selecionado;
    wire [31:0] resultado_mux1;

    //add
    wire [31:0] resultado_add4;
    wire [31:0] resultado_addDesvio;

    wire [31:0] reg_x1;

//=======================================================
//  Structural coding
//=======================================================

    pc_counter pc_cont(.clock(~KEY[0]), .pcIn(pcIn), .pcOut(pcOut), .reset(~KEY[1]));

    instruction_memory intru_mem(.clk(~KEY[0]), .PC(pcOut), .instruction(instruction), .reset(~KEY[1]));

    controlador control(.Opcode(instruction[6:0]), .ALUSrc(ALUSrc), .MemtoReg(MemtoReg), .RegWrite(RegWrite), .MemRead(MemRead), .MemWrite(MemWrite), .Branch(Branch), .jump(jump), .Aluop(Aluop));

    registradores regs(.clock(~KEY[0]), .escreverReg(RegWrite), .Rr1(instruction[19:15]), .Rr2(instruction[24:20]), .Wr(instruction[11:7]), .Wd(WriteData), .Rd1(Rd1), .Rd2(Rd2), .reset(~KEY[1]), .reg_x1(reg_x1[31:0]));

    immGen imm(.instrucao(instruction), .immediate(immediate));

    ALUcontrole alu_control(.aluop(Aluop), .funct7(instruction[30]), .funct3(instruction[14:12]), .controle(controle_alu));

    ALU alu(.controle(controle_alu), .a(Rd1), .b(resultado_mux1), .resultado(resultado_alu), .zero(zero));

    DataMemory data_mem(.clk(~KEY[0]), .MemWrite(MemWrite), .MemRead(MemRead), .endereco(resultado_alu), .WriteData(Rd2), .readData(readData), .W_ou_B(instruction[13]), .reset(~KEY[1]));

    branch branch_and(.Branch(Branch), .instrucao(instruction), .zero(zero), .saida(saida_branch));

    mux mux1(.ent0(Rd2), .ent1(immediate), .selecionado(ALUSrc), .resultado(resultado_mux1));

    mux mux2(.ent0(resultado_alu), .ent1(readData), .selecionado(MemtoReg), .resultado(WriteData));

    add add4(.a(pcOut), .b(4), .result(resultado_add4), .reset(~KEY[1]) , .clock(~KEY[0]));
    
    add addDesvio(.a(pcOut), .b(immediate), .result(resultado_addDesvio), .reset(~KEY[1]) , .clock(~KEY[0]));

    mux mux3(.ent0(resultado_add4), .ent1(resultado_addDesvio), .selecionado(saida_branch), .resultado(pcIn));

    // registrador 1
    display7 display0(.p4(reg_x1[3:0]), .saida(HEX0[6:0]), .clock(~KEY[0]));

    display7 display1(.p4(reg_x1[7:4]), .saida(HEX1[6:0]), .clock(~KEY[0]));

    display7 display2(.p4(reg_x1[11:8]), .saida(HEX2[6:0]), .clock(~KEY[0]));

    display7 display3(.p4(reg_x1[15:12]), .saida(HEX3[6:0]), .clock(~KEY[0]));

    // pcOut
    display7 display4(.p4(pcOut[3:0]), .saida(HEX4[6:0]), .clock(~KEY[0]));
  
    display7 display5(.p4(pcOut[7:4]), .saida(HEX5[6:0]), .clock(~KEY[0]));

    // clock
    display7 display6(.p4(~KEY[0]), .saida(HEX6[6:0]), .clock(~KEY[0]));

    // reset
    display7 display7(.p4(~KEY[1]), .saida(HEX7[6:0]), .clock(~KEY[0]));

endmodule

module display7(input [0:3] p4, output [0:6] saida, input clock);
    reg [6:0] SeteSegmentos; 
    // representa em 1 display 4 bits
    always @(p4) begin
      casez(p4)
        4'd0: SeteSegmentos = 7'b1000000; // 0
        4'd1: SeteSegmentos = 7'b1111001; // 1
        4'd2: SeteSegmentos = 7'b0100100; // 2
        4'd3: SeteSegmentos = 7'b0110000; // 3
        4'd4: SeteSegmentos = 7'b0011001; // 4
        4'd5: SeteSegmentos = 7'b0010010; // 5
        4'd6: SeteSegmentos = 7'b0000010; // 6
        4'd7: SeteSegmentos = 7'b1111000; // 7
        4'd8: SeteSegmentos = 7'b0000000; // 8
        4'd9: SeteSegmentos = 7'b0010000; // 9
        4'd10: SeteSegmentos = ~7'b1110111; // A
        4'd11: SeteSegmentos = ~7'b1111100; // B
        4'd12: SeteSegmentos = ~7'b0111001; // C
        4'd13: SeteSegmentos = ~7'b1011110; // D
        4'd14: SeteSegmentos = ~7'b1111001; // E
        4'd15: SeteSegmentos = ~7'b1110001; // F
        default: SeteSegmentos = ~7'b0000000; 
      endcase
    end

    assign saida = SeteSegmentos;

endmodule

module immGen(instrucao, immediate);
    input [31:0] instrucao;
    output reg [31:0] immediate;
  	reg [6:0] opcode;

	always @(*) begin
	opcode = instrucao[6:0];
		
		casez (opcode)
			7'b0000011 : begin 
			immediate = {{19{instrucao[31]}}, instrucao[31:20]}; // tipo lb
			if (((immediate % 4) == 0) && (immediate/4 < 32))
				immediate = immediate/4;
			end

			7'b0100011 : begin  
			immediate = {{19{instrucao[31]}}, instrucao[31:25], instrucao[11:7]}; // tipo s
			if ((immediate % 4) == 0)
				immediate = immediate/4;
			end

			7'b1100011 : begin  
			immediate = {{19{instrucao[31]}}, instrucao[31], instrucao[7], instrucao[30:25], instrucao[11:8]}; // tipo sb
			if ((immediate % 2) == 0)
				immediate = immediate << 1;
			end

			7'b0010011 : immediate = {{19{instrucao[31]}}, instrucao[31:20]}; // tipo I
				
			7'b1101111 : immediate = {{11{instrucao[31]}}, instrucao[31], instrucao[19:12], instrucao[20], instrucao[30:21]}; // tipo uj
			default: immediate[31:0] = 32'd0;
		endcase
	end

endmodule


module add(a, b, result, reset, clock);
  input  [31:0] a, b;
  output reg [31:0] result;
  input reset, clock;

  always @(clock) begin
    if (reset) result = 0;
    else begin
      casez({a[31], b[31]}) 
          2'b10:  result = b - (~(a) + 1);
          2'b01:  result = a - (~(b) + 1);
          default:  result = a + b;
      endcase
    end
  end

endmodule


module ALUcontrole(aluop, funct7,  funct3, controle);
    input [1:0] aluop;
    input funct7; 
    input [2:0] funct3;
    output reg [3:0] controle;
    
    /* alu_control com as principais funcoes aritmeticas 
        usa dos bits de selecao (aluop) e  dos valores
        da instrucao, caso necessario, para determinar qual
        operacao ira ser exec */ 
    always @(*) begin

        casez (aluop)
            2'b00 : controle = 4'b0010;
            2'b01 : controle = 4'b0110;
            2'b10 : casez({funct7,funct3})
                4'b0000 : controle = 4'b0010; // add
                4'b1000 : controle = 4'b0110; // sub
                4'b0111 : controle = 4'b0000; // and
                4'b0110 : controle = 4'b0001; // or
                4'b0001 : controle = 4'b0011; // sll
                4'b0100 : controle = 4'b0111; // xor
                4'b0101 : controle = 4'b1000; // srl
                default : controle = 4'bxxxx;
            endcase
            2'b11 : casez({funct7,funct3})
                4'b0000 : controle = 4'b0010; // addi
                4'b0100 : controle = 4'b0111; // xori
                4'b0110 : controle = 4'b0001; // ori
                4'b0111 : controle = 4'b0000; // andi
                4'b0001 : controle = 4'b0011; // slli
                4'b0101 : controle = 4'b1000; // srli
                default : controle = 4'bxxxx;
            endcase
        endcase
    end
endmodule


module ALU(
    input [3:0] controle, input [31:0] a,b,
    output reg [31:0] resultado, output zero
    );

    always @(*)
    begin
            casez({a[31], b[31]}) 
                2'b10: begin
                        casez(controle)
                            4'b0010: resultado = b - (~(a) + 1); // add e addi 
                            4'b0110: resultado = b + (~(a) + 1); // sub e subi e desvios condicial 
                        endcase
                    end
                2'b01: begin
                    casez(controle) 
                        4'b0010: resultado = a - (~(b) + 1); // add e addi 
                        4'b0110: resultado = a + (~(b) + 1); // sub e subi e desvios condicial 
                    endcase
                end
                default: begin
                    casez(controle)
                        4'b0000: resultado = a & b; // and e andi
                        4'b0001: resultado = a | b; // or e ori
                        4'b0010: resultado = a + b; // add e addi (ultimo bit é de sinal)
                        4'b0110: resultado = a - b; // sub e subi e desvios condicial (ultimo bit é de sinal)
                        4'b0011: resultado = a << b; // sll e slli
                        4'b0111: resultado = a ^ b; // xor e xori
                        4'b1000: resultado = a >> b; // srl e srli
                        default resultado = 32'bx; // valor default
                    endcase
                end
            endcase
    end 

    // zero vai ser usado para a operacao de branch (bne)
    assign zero = (resultado == 0) ? 1 : 0;
endmodule

module branch(input Branch, input [31:0] instrucao, input zero, output saida);

    wire eh_zero;
    wire aux;
    
    // condition ? if true : if false
    assign aux = (instrucao[12] == 1'b0) ? zero : !(zero); // controle = 0 (beq) 
    assign saida = aux & Branch;
endmodule

module controlador(Opcode, ALUSrc, MemtoReg, RegWrite, MemRead, MemWrite, Branch, jump, Aluop);
  input [6:0] Opcode;
  output wire ALUSrc, MemtoReg, RegWrite, MemRead, MemWrite, Branch, jump;
  output wire [1:0] Aluop;
  reg [8:0] controle; 
  
  /* atribuindo para todas as variaveis o mesmo valor (sinal de controle)
   usando o assing, pois toda vez que atualizar o controle atualiza as variaveis */
  always @(*)
    begin
      casez(Opcode)
        7'b0110011 : controle = 9'b001000010; // tipo R
        7'b0000011 : controle = 9'b111100000; // tipo lb
        7'b0100011 : controle = 9'b100010000; // tipo s
        7'b1100011 : controle = 9'b000001001; // tipo sb
        7'b0010011 : controle = 9'b101000011; // tipo I
        7'b1101111 : controle = 9'b111xx0100; // tipo uj
        default : controle    = 9'bxxxxxxxxx; // don't cares
      endcase
  end
  
    assign {ALUSrc, MemtoReg, RegWrite, MemRead, MemWrite, Branch, jump, Aluop} = controle;

endmodule


module DataMemory(clk, MemWrite, MemRead, endereco, WriteData, readData, W_ou_B, reset);
  input clk, MemWrite, MemRead, W_ou_B, reset;

  input [31:0] endereco, WriteData;
  output reg [31:0] readData;
  reg [31:0] memory [31:0];

   always@(posedge clk) begin
    if(reset == 1'b1) begin
      memory[0] = 32'b00000000000010000000000011000000;
      memory[1] = 32'b00000000000000000000000000011001;
      memory[2] = 32'b00000000000000000000000001101110;
      memory[3] = 32'b00000000000000000000000001111010;
      memory[4] = 32'b00000000000000000000000001100111;
      memory[5] = 32'b00000000000000000000000000110000;
      memory[6] = 32'b00000000000000000000000000101110;
      memory[7] = 32'b00000000000000000000000001100110;
      memory[8] = 32'b00000000000000000000000001111101;
      memory[9] = 32'b00000000000000000000000000010000;
      memory[10] = 32'b00000000000000000000000001000111;
      memory[11] = 32'b00000000000000000000000001101100;
      memory[12] = 32'b00000000000000000000000001011010;
      memory[13] = 32'b00000000000000000000000000111101;
      memory[14] = 32'b00000000000000000000000001001000;
      memory[15] = 32'b00000000000000000000000000010111;
      memory[16] = 32'b00000000000000000000000001001101;
      memory[17] = 32'b00000000000000000000000001110111;
      memory[18] = 32'b00000000000000000000000000110010;
      memory[19] = 32'b00000000000000000000000001100101;
      memory[20] = 32'b00000000000000000000000001101010;
      memory[21] = 32'b00000000000000000000000000000010;
      memory[22] = 32'b00000000000000000000000000100111;
      memory[23] = 32'b00000000000000000000000000100101;
      memory[24] = 32'b00000000000000000000000000100000;
      memory[25] = 32'b00000000000000000000000001110100;
      memory[26] = 32'b00000000000000000000000001110111;
      memory[27] = 32'b00000000000000000000000000011110;
      memory[28] = 32'b00000000000000000000000001000000;
      memory[29] = 32'b00000000000000000000000001010011;
      memory[30] = 32'b00000000000000000000000000011100;
      memory[31] = 32'b00000000000000000000000000101101;
    end 

    casez({MemRead, MemWrite})
        2'b10: begin
        casez (W_ou_B)
            1'b0:  readData = memory[endereco][7:0];
            default: readData = memory[endereco];

          endcase
        end  

        2'b01: begin
            memory[endereco] = WriteData;
      end
    endcase 
  end

endmodule


module instruction_memory(
    input clk,  input [31:0] PC, input reset,
    output [31:0] instruction
);
    reg [31:0] memoria [256:0];
    
    always@(posedge clk) begin
        if(reset == 1'b1) begin
          

            memoria[0] = 32'b00000000000000000000000000000000;
            // "nop", pra mostrar o estado inicial

            memoria[4] = 32'b00000000001100010000000010110011;
            // add x1, x2, x3
            // x1 = 5

            memoria[8] = 32'b00000000001000001000000010010011;
            // addi x1, x1, 2
            // x1 = 7
            
            memoria[12] = 32'b01000000001100001000000010110011;
            //sub x1, x1, x3
            // x1 = 4
            
            memoria[16] = 32'b00000000010000110001100001100011; 
            // bne x6, x4, 16
            // pcOut = 16 + 16 = 32 decimal = 20 hexa

            memoria[20] = 32'b00000000011000001000000010110011;
            //add x1, x1, x6
            // x1 = 13
            // entretanto é pulado pelo bne entao nao atualiza o valor do x1

            memoria[24] = 32'b00000000001100010000000110110011;
            memoria[28] = 32'b00000000001100010000000110110011;
            memoria[32] = 32'b00000000001100010000000110110011;
            memoria[36] = 32'b00000000001100010000000110110011;
            memoria[40] = 32'b00000000001100010000000110110011;
            memoria[44] = 32'b00000000001100010000000110110011;
            memoria[48] = 32'b00000000001100010000000110110011;
            memoria[52] = 32'b00000000001100010000000110110011;
            memoria[56] = 32'b00000000001100010000000110110011;
            memoria[60] = 32'b00000000001100010000000110110011;
            // add x3, x2, x3
            // nao interverem no resultado final do registrador x1
            

            // memoria[0] = 32'b00000000000100000000001000100011; //sb x1, 4(x0)
            // memoria[4] = 32'b00000000010100110000000110110011; // add x3, x6, x5
            // memoria[8] = 32'b00000000010000000000000100000011; // lb x2, 4(x0)
            // memoria[12] = 32'b01000000001000100000001010110011; // sub x5, x4, x2
            // memoria[16] = 32'b00000000010000011110000100110011; // or x2, x3, x4
            // memoria[20] = 32'b00000000000100000010000000100011; // sw x1, 0(x0)
            // memoria[24] = 32'b00000000010000110001001001100011; // bne x6, x4, 4
            // memoria[28] = 32'b00000000011000011111000110110011; // and x3, x3, x6
            // memoria[32] = 32'b00000000100000000010000110000011; // lw x3, 8(x0)
            // memoria[36] = 32'b00000000010000110000001001100011; // beq x6, x4, 4
            // memoria[40] = 32'b00000000001000100110001010010011; // ori x5, x4, 2
            // memoria[44] = 32'b00000000011100110001000100110011; // sll x2, x6, x7
        end 
  end
    
    assign instruction = memoria[PC];

endmodule


module mux(ent0, ent1, selecionado, resultado);
  input wire [31:0] ent0;
  input wire [31:0] ent1;
  input wire selecionado;
  output [31:0] resultado;
  
  assign resultado = (selecionado == 1'b0) ? ent0 : ent1;
endmodule

module registradores(clock, escreverReg, Rr1, Rr2, Wr, Wd, Rd1, Rd2, reset, reg_x1);
  input clock, escreverReg, reset;
  input [4:0] Rr1;
  input [4:0] Rr2; 
  input [4:0] Wr; 
  input [31:0] Wd;
  output [31:0] Rd1;
  output [31:0] Rd2;
  output [31:0] reg_x1;
  
  reg [31:0] registradores [31:0]; // vetor de valores dos regs 
  reg [31:0] i;

  always @(posedge clock) begin
    if(reset == 1'b1) begin
      // inicia todos os registradores com o valor do indice referente a ele
      registradores[0] = 32'd0;
      registradores[1] = 32'd1;
      registradores[2] = 32'd2;
      registradores[3] = 32'd3;
      registradores[4] = 32'd4;
      registradores[5] = 32'd5;
      registradores[6] = 32'd6;
      registradores[7] = 32'd7;
      registradores[8] = 32'd8;
      registradores[9] = 32'd9;
      registradores[10] = 32'd10;
      registradores[11] = 32'd11;
      registradores[12] = 32'd12;
      registradores[13] = 32'd13;
      registradores[14] = 32'd14;
      registradores[15] = 32'd15;
      registradores[16] = 32'd16;
      registradores[17] = 32'd17;
      registradores[18] = 32'd18;
      registradores[19] = 32'd19;
      registradores[20] = 32'd20;
      registradores[21] = 32'd21;
      registradores[22] = 32'd22;
      registradores[23] = 32'd23;
      registradores[24] = 32'd24;
      registradores[25] = 32'd25;
      registradores[26] = 32'd26;
      registradores[27] = 32'd27;
      registradores[28] = 32'd28;
      registradores[29] = 32'd29;
      registradores[30] = 32'd30;
      registradores[31] = 32'd31;
    end


    if(escreverReg) begin
        registradores[Wr] = Wd;
    end

  end

  // valor do registrador x1 sendo salvo para printar
  assign reg_x1 = registradores[1];
  
  // saidas recebem valores do banco (menos o 0x que é sempre 0)
  assign Rd1 = (Rr1 != 0) ? registradores[Rr1] : 0;
  assign Rd2 = (Rr2 != 0) ? registradores[Rr2] : 0;
endmodule

module pc_counter(clock, pcIn, pcOut, reset);
  input clock, reset;
  output reg [31:0] pcOut;
  input [31:0] pcIn;

  // ao subir a borda de clock vai mudar o endereco do nosso reg, se ele não estiver no modo de reset [em que zeramos todas nossas variaveis] (o novo end vai vir do mux)
  always@(posedge clock) begin
    if(reset == 1'b1) pcOut = 32'd0;
    else begin
        pcOut = pcIn;
    end
  end
endmodule


